using Spectre.Console;
using Spectre.Console.Cli;
using MemGuard.Core;
using MemGuard.Core.Interfaces;
using MemGuard.Core.Services;
using MemGuard.Infrastructure;
using MemGuard.Infrastructure.Extractors;
using MemGuard.AI;
using MemGuard.Reporters;
using MemGuard.Cli.Models;
using Microsoft.Extensions.DependencyInjection;
using System.Diagnostics;

namespace MemGuard.Cli.Commands;

public sealed class FixDumpCommand : AsyncCommand<FixDumpSettings>
{
    public override async Task<int> ExecuteAsync(CommandContext context, FixDumpSettings settings)
    {
        ArgumentNullException.ThrowIfNull(settings);

        try
        {
            AnsiConsole.Write(new FigletText("MemGuard Fix").Color(Color.Blue));
            AnsiConsole.MarkupLine("[grey]AI-Powered Code Fixer[/]");
            AnsiConsole.WriteLine();

            if (string.IsNullOrEmpty(settings.ProjectPath))
            {
                AnsiConsole.MarkupLine("[red]Error:[/] --project path is required for fix command");
                return 1;
            }

            AnsiConsole.Write(new Markup("[yellow]Analyzing:[/] "));
            AnsiConsole.WriteLine(settings.DumpPath);
            AnsiConsole.Write(new Markup("[yellow]Project:[/] "));
            AnsiConsole.WriteLine(settings.ProjectPath);
            AnsiConsole.Write(new Markup("[yellow]Provider:[/] "));
            AnsiConsole.WriteLine(settings.Provider);
            AnsiConsole.Write(new Markup("[yellow]Mode:[/] "));
            AnsiConsole.WriteLine(settings.DryRun ? "Dry Run (Preview Only)" : "Apply Fixes");
            AnsiConsole.WriteLine();

            // Create service collection and configure dependencies
            var services = new ServiceCollection();
            ConfigureServices(services, settings);
            var serviceProvider = services.BuildServiceProvider();

            var dumpParser = serviceProvider.GetRequiredService<IDumpParser>();
            var extractors = serviceProvider.GetRequiredService<IEnumerable<IDiagnosticExtractor>>();
            var llmClient = serviceProvider.GetRequiredService<ILLMClient>();
            var codeFixer = serviceProvider.GetRequiredService<ICodeFixer>();
            var telemetry = serviceProvider.GetRequiredService<TelemetryService>();

            using var activity = telemetry.StartAnalysisActivity(settings.DumpPath);
            var stopwatch = Stopwatch.StartNew();

            // Step 1: Load dump and extract diagnostics
            var diagnostics = new List<DiagnosticBase>();
            
            await AnsiConsole.Status()
                .Spinner(Spinner.Known.Dots)
                .StartAsync("Analyzing dump...", async ctx =>
                {
                    ctx.Status("Loading dump...");
                    using var runtime = dumpParser.LoadDump(settings.DumpPath);
                    
                    ctx.Status("Extracting diagnostics...");
                    foreach (var extractor in extractors)
                    {
                        var diagnostic = await extractor.ExtractAsync(runtime);
                        if (diagnostic != null)
                        {
                            diagnostics.Add(diagnostic);
                        }
                    }
                    
                    ctx.Status("Requesting AI fixes...");
                    var prompt = PromptBuilder.BuildFixPrompt(diagnostics, settings.ProjectPath);
                    var aiResponse = await llmClient.GenerateResponseAsync(prompt);
                    
                    ctx.Status("Parsing and applying fixes...");
                    var fixResult = await codeFixer.ApplyFixesAsync(aiResponse, settings.ProjectPath!, settings.DryRun);
                    
                    stopwatch.Stop();
                    
                    // Display results
                    AnsiConsole.WriteLine();
                    AnsiConsole.MarkupLine($"[green]Analysis completed in {stopwatch.Elapsed.TotalSeconds:F1}s[/]");
                    AnsiConsole.WriteLine();

                    if (fixResult.AppliedFixes.Count == 0)
                    {
                        AnsiConsole.MarkupLine("[yellow]No fixes were generated by the AI[/]");
                        return;
                    }

                    // Show fixes
                    var table = new Table();
                    table.AddColumn("File");
                    table.AddColumn("Status");
                    
                    foreach (var fix in fixResult.AppliedFixes)
                    {
                        var fileName = Path.GetFileName(fix.FilePath);
                        table.AddRow(fileName.EscapeMarkup(), settings.DryRun ? "[yellow]Preview[/]" : "[green]Applied[/]");
                    }
                    
                    AnsiConsole.Write(table);
                    AnsiConsole.WriteLine();

                    // Show diffs
                    foreach (var fix in fixResult.AppliedFixes)
                    {
                        AnsiConsole.MarkupLine($"[blue]Diff for {Path.GetFileName(fix.FilePath).EscapeMarkup()}:[/]");
                        var panel = new Panel(fix.UnifiedDiff.EscapeMarkup())
                        {
                            Border = BoxBorder.Rounded,
                            BorderStyle = new Style(Color.Grey)
                        };
                        AnsiConsole.Write(panel);
                        AnsiConsole.WriteLine();
                    }

                    if (!settings.DryRun && fixResult.BackupId != null)
                    {
                        AnsiConsole.MarkupLine($"[green]Backup created:[/] {fixResult.BackupId}");
                        AnsiConsole.MarkupLine($"[grey]To restore: memguard restore --backup-id {fixResult.BackupId}[/]");
                    }

                    if (fixResult.Errors.Count > 0)
                    {
                        AnsiConsole.MarkupLine("[red]Errors:[/]");
                        foreach (var error in fixResult.Errors)
                        {
                            AnsiConsole.MarkupLine($"  [red]â€¢[/] {error.EscapeMarkup()}");
                        }
                    }
                });

            return 0;
        }
        catch (Exception ex)
        {
            AnsiConsole.MarkupLine($"[red]Error:[/] {ex.Message.EscapeMarkup()}");
            if (ex.InnerException != null)
            {
                AnsiConsole.MarkupLine($"[red]Details:[/] {ex.InnerException.Message.EscapeMarkup()}");
            }
            return 1;
        }
    }

    private static void ConfigureServices(IServiceCollection services, FixDumpSettings settings)
    {
        // Infrastructure
        services.AddSingleton<TelemetryService>();
        services.AddSingleton<IDumpParser, DumpParser>();
        services.AddSingleton<IBackupManager, BackupManager>();
        services.AddSingleton<ICodeFixer, CodeFixer>();
        
        // Extractors
        services.AddSingleton<IDiagnosticExtractor, HeapExtractor>();
        services.AddSingleton<IDiagnosticExtractor, DeadlockExtractor>();
        
        // AI Client
        if (settings.Provider.Equals("Gemini", StringComparison.OrdinalIgnoreCase))
        {
            services.AddHttpClient<GeminiClient>();
            services.AddSingleton<ILLMClient>(sp => 
            {
                var httpClient = sp.GetRequiredService<IHttpClientFactory>().CreateClient(nameof(GeminiClient));
                
                if (string.IsNullOrEmpty(settings.ApiKey))
                {
                    throw new InvalidOperationException("API key is required. Use --api-key option or set MEMGUARD_GEMINI_KEY environment variable.");
                }
                
                return new GeminiClient(httpClient, settings.ApiKey, settings.Model);
            });
        }
        else
        {
            services.AddSingleton<ILLMClient>(sp => 
                new OllamaClient("http://localhost:11434", settings.Model ?? "llama3.2"));
        }
    }
}
