using MemGuard.Core;
using MemGuard.Core.Interfaces;
using Microsoft.Diagnostics.Runtime;

namespace MemGuard.Infrastructure.Extractors;

/// <summary>
/// Extractor that detects exploit techniques including ROP chains, shellcode, ETW tampering, and debugger evasion
/// </summary>
public class ExploitHeuristicsExtractor : IDiagnosticExtractor
{
    public string Name => "ExploitHeuristics";

    // Common shellcode patterns (opcode sequences)
    private static readonly byte[][] ShellcodePatterns = new[]
    {
        new byte[] { 0x90, 0x90, 0x90, 0x90 }, // NOP sled
        new byte[] { 0xEB, 0xFE },              // JMP $-2 (infinite loop)
        new byte[] { 0x31, 0xC0 },              // XOR EAX, EAX
        new byte[] { 0xCC },                    // INT3 (breakpoint)
    };

    // Common ROP gadgets (return addresses pattern)
    private static readonly string[] RopGadgetPatterns = new[]
    {
        "pop,ret",
        "pop,pop,ret",
        "xchg,ret",
        "add,ret",
    };

    public async Task<DiagnosticBase?> ExtractAsync(ClrRuntime runtime, CancellationToken cancellationToken = default)
    {
        var techniques = new List<ExploitTechnique>();

        await Task.Run(() =>
        {
            // 1. Detect ROP chains
            var ropDetection = DetectRopChains(runtime, cancellationToken);
            if (ropDetection != null)
                techniques.Add(ropDetection);

            // 2. Detect shellcode patterns
            var shellcodeDetection = DetectShellcode(runtime, cancellationToken);
            if (shellcodeDetection != null)
                techniques.Add(shellcodeDetection);

            // 3. Detect ETW tampering
            var etwDetection = DetectEtwTampering(runtime, cancellationToken);
            if (etwDetection != null)
                techniques.Add(etwDetection);

            // 4. Detect debugger evasion
            var debuggerDetection = DetectDebuggerEvasion(runtime, cancellationToken);
            if (debuggerDetection != null)
                techniques.Add(debuggerDetection);

        }, cancellationToken);

        var overallRisk = CalculateOverallRisk(techniques);

        return new ExploitDiagnostic(techniques, overallRisk);
    }

    private ExploitTechnique? DetectRopChains(ClrRuntime runtime, CancellationToken cancellationToken)
    {
        try
        {
            var evidence = new List<string>();
            var suspiciousStackPatterns = 0;

            // Analyze thread stacks for ROP chain patterns
            foreach (var thread in runtime.Threads)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var frames = thread.EnumerateStackTrace().ToList();
                if (frames.Count < 5)
                    continue;

                // Look for unusual return address patterns
                var returnAddresses = frames
                    .Where(f => f.InstructionPointer != 0)
                    .Select(f => f.InstructionPointer)
                    .ToList();

                // Check for suspicious patterns (many consecutive small offsets)
                for (int i = 0; i < returnAddresses.Count - 3; i++)
                {
                    var diff1 = Math.Abs((long)returnAddresses[i + 1] - (long)returnAddresses[i]);
                    var diff2 = Math.Abs((long)returnAddresses[i + 2] - (long)returnAddresses[i +1]);
                    var diff3 = Math.Abs((long)returnAddresses[i + 3] - (long)returnAddresses[i + 2]);

                    // Small, consecutive offsets might indicate ROP gadgets
                    if (diff1 < 0x20 && diff2 < 0x20 && diff3 < 0x20)
                    {
                        suspiciousStackPatterns++;
                        evidence.Add($"Thread {thread.OSThreadId}: Suspicious ROP pattern at 0x{returnAddresses[i]:X}");
                        break; // One per thread is enough
                    }
                }

                if (suspiciousStackPatterns >= 2)
                    break; // Enough evidence
            }

            if (suspiciousStackPatterns > 0)
            {
                return new ExploitTechnique(
                    "ROP Chain",
                    "Detected potential Return-Oriented Programming (ROP) chain exploitation",
                    0.7,
                    evidence);
            }
        }
        catch
        {
            // Continue with other detections
        }

        return null;
    }

    private ExploitTechnique? DetectShellcode(ClrRuntime runtime, CancellationToken cancellationToken)
    {
        try
        {
            var evidence = new List<string>();
            var nopSledCount = 0;

            // Look for executable memory regions with shellcode patterns
            // In ClrMD, we can check heap segments for unusual patterns
            foreach (var segment in runtime.Heap.Segments)
            {
                cancellationToken.ThrowIfCancellationRequested();

                // Check for unusual executable patterns (simplified heuristic)
                // In a real implementation, you'd read memory bytes and scan for patterns
                
                // For demonstration, we'll check for suspicious object types
                var executableLikeObjects = runtime.Heap.EnumerateObjects()
                    .Where(obj => obj.Type?.Name?.Contains("Byte[]") == true && obj.Size > 100 && obj.Size < 10000)
                    .Take(50);

                foreach (var obj in executableLikeObjects)
                {
                    try
                    {
                        // In production, read the byte array and scan for shellcode patterns
                        // For now, we'll use size and address as heuristics
                        if (obj.Address % 0x1000 == 0) // Page-aligned might indicate injected code
                        {
                            nopSledCount++;
                            evidence.Add($"Suspicious byte array at 0x{obj.Address:X}, size: {obj.Size} bytes");
                        }
                    }
                    catch
                    {
                        continue;
                    }

                    if (nopSledCount >= 3)
                        break;
                }

                if (nopSledCount >= 3)
                    break;
            }

            if (nopSledCount > 0)
            {
                return new ExploitTechnique(
                    "Shellcode",
                    "Detected potential shellcode or injected code patterns",
                    0.6,
                    evidence);
            }
        }
        catch
        {
            // Continue
        }

        return null;
    }

    private ExploitTechnique? DetectEtwTampering(ClrRuntime runtime, CancellationToken cancellationToken)
    {
        try
        {
            var evidence = new List<string>();
            
            // Check for ETW-related objects that might be tampered
            var etwObjects = runtime.Heap.EnumerateObjects()
                .Where(obj => obj.Type?.Name?.Contains("Etw") == true || 
                              obj.Type?.Name?.Contains("EventSource") == true)
                .Take(100)
                .ToList();

            if (etwObjects.Count == 0)
            {
                // Suspiciously no ETW objects - might indicate tampering
                evidence.Add("No ETW provider objects found - possible ETW suppression");
                
                return new ExploitTechnique(
                    "ETW Tampering",
                    "Potential Event Tracing for Windows (ETW) tampering detected",
                    0.5,
                    evidence);
            }

            // Check for unusual ETW object counts
            if (etwObjects.Count < 3)
            {
                evidence.Add($"Unusually low ETW object count: {etwObjects.Count}");
                
                return new ExploitTechnique(
                    "ETW Tampering",
                    "Potential ETW suppression or tampering",
                    0.4,
                    evidence);
            }
        }
        catch
        {
            // Continue
        }

        return null;
    }

    private ExploitTechnique? DetectDebuggerEvasion(ClrRuntime runtime, CancellationToken cancellationToken)
    {
        try
        {
            var evidence = new List<string>();
            
            // Look for common anti-debugging techniques
            // Check for timing-based checks (many Thread.Sleep calls)
            var sleepCalls = runtime.Threads
                .SelectMany(t => t.EnumerateStackTrace())
                .Where(f => f.Method?.Name?.Contains("Sleep") == true ||
                           f.Method?.Name?.Contains("Delay") == true)
                .Count();

            if (sleepCalls > 5)
            {
                evidence.Add($"Detected {sleepCalls} sleep/delay calls - possible timing-based anti-debugging");
            }

            // Check for Debugger.IsAttached checks in stack traces
            var debuggerChecks = runtime.Threads
                .SelectMany(t => t.EnumerateStackTrace())
                .Where(f => f.Method?.Name?.Contains("IsAttached") == true ||
                           f.Method?.Type?.Name?.Contains("Debugger") == true)
                .Count();

            if (debuggerChecks > 0)
            {
                evidence.Add($"Detected {debuggerChecks} debugger detection calls");
            }

            if (evidence.Count > 0)
            {
                return new ExploitTechnique(
                    "Debugger Evasion",
                    "Detected anti-debugging or analysis evasion techniques",
                    0.6,
                    evidence);
            }
        }
        catch
        {
            // Continue
        }

        return null;
    }

    private double CalculateOverallRisk(List<ExploitTechnique> techniques)
    {
        if (techniques.Count == 0)
            return 0.0;

        // Weight by confidence and number of techniques
        var avgConfidence = techniques.Average(t => t.Confidence);
        var countMultiplier = Math.Min(techniques.Count * 0.2, 0.8); // Cap at 0.8

        return Math.Min(avgConfidence + countMultiplier, 1.0);
    }
}
