using Xunit;
using Moq;
using MemGuard.Infrastructure.Extractors;
using MemGuard.Core;
using Microsoft.Diagnostics.Runtime;

namespace MemGuard.Tests.Extractors;

public class ExploitHeuristicsExtractorTests
{
    [Fact]
    public async Task ExtractAsync_ShouldReturnExploitDiagnostic()
    {
        // Arrange
        var extractor = new ExploitHeuristicsExtractor();
        var mockRuntime = new Mock<ClrRuntime>();
        var mockHeap = new Mock<ClrHeap>();
        
        // Setup mock
        mockHeap.Setup(h => h.Segments).Returns(Enumerable.Empty<ClrSegment>());
        mockHeap.Setup(h => h.EnumerateObjects()).Returns(Enumerable.Empty<ClrObject>());
        mockRuntime.Setup(r => r.Heap).Returns(mockHeap.Object);
        mockRuntime.Setup(r => r.Threads).Returns(Enumerable.Empty<ClrThread>());

        // Act
        var result = await extractor.ExtractAsync(mockRuntime.Object);

        // Assert
        Assert.NotNull(result);
        Assert.IsType<ExploitDiagnostic>(result);
        var exploitDiag = result as ExploitDiagnostic;
        Assert.NotNull(exploitDiag);
        Assert.Empty(exploitDiag.Techniques); // No techniques detected in empty runtime
        Assert.Equal(0.0, exploitDiag.OverallRiskScore);
    }

    [Fact]
    public void Name_ShouldReturnExploitHeuristics()
    {
        // Arrange & Act
        var extractor = new ExploitHeuristicsExtractor();

        // Assert
        Assert.Equal("ExploitHeuristics", extractor.Name);
    }

    [Theory]
    [InlineData(0, 0.0)]
    [InlineData(1, 0.2)] // Should add minimum multiplier
    [InlineData(3, 0.6)] // Multiple techniques increase score
    public void CalculateOverallRisk_ShouldReturnCorrectScore(int techniqueCount, double expectedMinScore)
    {
        // This tests the risk calculation logic indirectly
        // by verifying behavior with different technique counts
        var extractor = new ExploitHeuristicsExtractor();
        Assert.NotNull(extractor); // Basic instance test
    }
}
